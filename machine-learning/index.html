<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Machine Learning</title>
  <meta name="description" content="Muslim technology entrepeneur. Learn by doing.
">

  <link href="https://fonts.googleapis.com/css?family=Lato:900|Work+Sans" rel="stylesheet">
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://yaz.in/machine-learning/">
  <link rel="alternate" type="application/rss+xml" title="Yazin Alirhayim" href="https://yazin.org/feed.xml">

  <script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  <script>
  (function(){
  	/* permanently redirect all traffic to https, keeping the path */
    var fullPath, host, ptnHost, subPath, ptnSubPath, result;

    ptnHost = /^https?:\/\/([a-z0-9.]*)[:\d]*?\/.*$/i; // localhost, google.com
    ptnSubPath = /^http:\/\/(.*?)(\/.*)$/i; // *, where "http://host/*"

    fullPath = window.location.toString();
    host = ptnHost.exec(fullPath); host = host[host.length - 1];
    subPath = ptnSubPath.exec(fullPath);
    if(subPath !== null && host != "localhost" && host != "127.0.0.1") {
      /* production URL thats using HTTP -- redirect to HTTPS sub-path */
      window.location.protocol = "https:";
    }
  })(); 
  </script>
</head>

<body>
<header> 
  <div class="links"> 
  
    
  
     
      <a class="page-link" href="/bookshelf/">My Bookshelf</a>
    
  
    
  
     
      <a class="page-link" href="/experiments/">Experiments</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
     
      <a class="page-link" href="/projects/">Projects</a>
    
  
    
  
    
  
    
  
    
  
  </div>
</header>


  
    <h1 class="page-title">Machine Learning</h1>
  

  <div class="meta"><span>December 19, 2016</span></div>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<ul class="post-list">
  
    <li>
      <h2> 
        <a class="post-link" href="/machine-learning/ahoy-there/">Ahoy there!</a>
      </h2>
      <div class="post-content">
        <p>Well hello. My name’s <a href="https://twitter.com/yazinsai">Yazin</a> and I’m a regular guy just like you. I’ve dabbled with a bit of code in the past, namely Ruby and PHP, but I wouldn’t consider myself an expert.</p>

<p>Lately, I’ve been hearing alot about Machine Learning, and I was intrigued. One thing that I found especially interesting was <a href="http://tensorflow.org">Tensorflow</a>, the Machine Learning brain that Google had open sourced just last week!</p>

<p>This was it .. I wanted to know more. However, there’s a ton of material out there on Machine Learning, and the topic can seem abit intimidating (especially with all the weird looking math functions).</p>

<p>I heard that the best way to learn was to teach, so I’ll be documenting everything I learn here. If I don’t understand something, I’ll just say so – instead of attempting to BS my way through.</p>

<p>So that’s it, I hope you’ll join me for the journey!</p>

      </div>
    </li>
  
    <li>
      <h2> 
        <a class="post-link" href="/machine-learning/first-post/">First Post! The Types of Machine Learning</a>
      </h2>
      <div class="post-content">
        <p>Here’s what I learned today:</p>

<ul>
  <li>There are a bunch of different types of Machine Learning.</li>
  <li>A general impression of what can (and can’t) be achieved using Machine Learning.</li>
</ul>

<h3 id="types-of-machine-learning">Types of Machine Learning</h3>

<p>There are two main types of Machine Learning:</p>

<ol>
  <li>Supervised</li>
  <li>Unsupervised</li>
</ol>

<p>You kinda get a general sense for what these two categories might entail, but let’s talk about them abit more.</p>

<h4 id="1-supervised-machine-learning">1. Supervised Machine Learning</h4>

<p>In supervised learning, we are given a data set and already know what our correct output should look like .. this usually means we have some sort of hunch about the relationship between the input and the output.</p>

<p>The Supervised category is further divided into 2 subcategories:</p>

<ul>
  <li><strong>Regression problems</strong>: it’s where we are trying to map the inputs to a continuous output .. with infinite possible values. <em>(Example: trying to predict the price of a stock based on historical performance of that stock)</em></li>
  <li><strong>Classification problems</strong>: this is where the output we’re trying to predict has a bunch of possible values, and our job is to figure out which category it falls under. <em>(Example: given a cute picture of a kittie, trying to figure out which species it belongs to)</em></li>
</ul>

<h4 id="2-unsupervised-machine-learning">2. Unsupervised Machine Learning</h4>

<p>Unsupervised learning, on the other hand, allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables.</p>

<p>We can derive this structure by clustering the data based on relationships among the variables in the data.</p>

<p>With unsupervised learning there is no feedback based on the prediction results, i.e., there is no teacher to correct you. It’s not just about clustering. For example, associative memory is unsupervised learning.</p>

<p>There are a bunch of categories of unsupervised machine learning:</p>

<ul>
  <li><strong>Associative</strong>: Take a collection of 1000 essays written on the US Economy, and find a way to automatically group these essays into a small number that are somehow similar or related by different variables, such as word frequency, sentence length, page count, and so on.</li>
  <li><strong>Clustering</strong>: Suppose a doctor over years of experience forms associations in his mind between patient characteristics and illnesses that they have. If a new patient shows up then based on this patient’s characteristics such as symptoms, family medical history, physical attributes, mental outlook, etc the doctor associates possible illness or illnesses based on what the doctor has seen before with similar patients. This is not the same as rule based reasoning as in expert systems. In this case we would like to estimate a mapping function from patient characteristics into illnesses.</li>
</ul>

      </div>
    </li>
  
    <li>
      <h2> 
        <a class="post-link" href="/machine-learning/some-basic-definitions/">Some Basic definitions</a>
      </h2>
      <div class="post-content">
        <p>Here’s what I learned today:</p>

<ul>
  <li>The goal of supervised Machine Learning is to try to make <strong>good guesses</strong>, given the output of many previous guesses.</li>
  <li>How to translate problems from plains words to some juicy mathematics (oh joy!).</li>
</ul>

<h3 id="goal-of-supervised-machine-learning">Goal of supervised Machine Learning</h3>

<p>Apparently, the entire purpose of supervised Machine Learning is to try and predict an output given (one or more) inputs.</p>

<h3 id="some-definitions">Some definitions</h3>
<p>In the examples I followed, Andrew took the case of housing prices. His imaginary friend, James, wanted to sell his house and came to Andrew asking for advice. What he then did was look at a bunch of different factors (e.g size of the house) and the impact this had on the price of the house.</p>

<p>There’s a couple of important definitions to note here:</p>

<ol>
  <li>The price of the house (what we’re trying to estimate) is called the <strong>output</strong>, referred to by the symbol (y) (I can now write fancy math symbols, thanks to <a href="http://gastonsanchez.com/blog/opinion/2014/02/16/Mathjax-with-jekyll.html">Mr.Gaston Sanchez’s post</a> )</li>
  <li>The inputs that influence the price of the house (or that we think influence it anyway) are called .. well, <strong>inputs</strong>. The symbol for those is \(x\) (and potentially, \(x_1\), \(x_2\), …).</li>
  <li>Our goal, in a supervised learning scenario is to come up with some sort of <strong>relationship</strong> (equation, not that other type you silly person) between the input(s) and the output. We’d then be able to use that relationship to predict the \(y\) from the \(x\)’s. This relationship is called a hypothesis, and is referenced by the symbol \(h\).</li>
</ol>

<p>Let’s talk abit more about point #3 above, about the hypothesis \(h\). Essentially, if the relationship is linear (Andrew promises to tell us later how to get the best possible fit, linear or otherwise), then the relationship takes the form of:</p>

<script type="math/tex; mode=display">h = \theta_0 + \theta_1 x</script>

<p>This looks kinda similar to an equation I remember from school:</p>

<script type="math/tex; mode=display">y = mx + c \text{ (or } y = c + mx)</script>

<p>That’s the straight line formula, where \(m\) is the gradient/slope, \(c\) is the y-intercept and \(x, y\) are both coordinates of any point on the line. It’s clear, just by comparing the two, that \(\theta_0 = c\) (the y-intercept) and \(\theta_1 = m\) (the gradient/slope). In general, we call these \(\theta\) things <strong>parameters</strong> of the hypothesis (so we don’t have to call them <em>theta things</em> the whole time).</p>

<p>The bottom line is this: if we know (or can somehow calculate) what the parameters (\(\theta_0, \theta_1\)) are, then we can predict the values of \(y\) given \(x\).. all without even needing a crystal ball!</p>

<p><em>For our purposes, we’re not supposed to dig too deep into this just yet. Things get icky pretty quickly when you add multiple \(x\)’s, and higher order hypotheses (like quadratic equations, cubic equations, etc.).</em></p>

<p><em>Let’s not worry about all that just yet .. and focus on getting this darn thing to work with the most basic case first.</em></p>

<h3 id="training-data">Training data</h3>
<p>Like we said earlier, we’ll be given a bunch of training data (which are really just \((x, y)\) pairs .. and later asked to predict the value of \(y\) when given \(x\).</p>

<p>Here’s what a sample training data set might look like:</p>

<table>
  <thead>
    <tr>
      <th>Size in ft<sup>2</sup></th>
      <th>Price (x $1,000)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2104</td>
      <td>460</td>
    </tr>
    <tr>
      <td>1416</td>
      <td>232</td>
    </tr>
    <tr>
      <td>1534</td>
      <td>315</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
    </tr>
  </tbody>
</table>

<p>The total number of rows (or pairs) of training data is called \(m\), and we’ll be using that a bunch of times in our calculations.</p>

<p>Now, our job, as mentioned earlier is to find a relationship that connects our features (\(x\)’s) to our predicted value of \(y\).</p>

<p>We’ve now got a bunch of points, and we’re trying to predict the \(y\) value given an \(x\) .. you can probably already see where this is going .. we need to find the <strong>line of best fit</strong>.</p>

<h3 id="finding-the-line-of-best-fit">Finding the line of best fit</h3>
<p>Calculating the line of best fit is pretty easy to do, visually (see my hand-drawn masterpiece below).</p>

<p><img src="/assets/machine-learning/line-of-best-fit.png" alt="Line of best fit" /></p>

<p>When you try to do it in math though, the equations can end up looking pretty scary. The concept however is a simple one.</p>

<p>To get the line of best fit, you first need to define what “fit” means .. in our case, this means calculating some sort of figure that allows you to differentiate a “good” fit from a bad one.</p>

<p>We call this the <strong>cost function</strong>. To find the cost of a particular hypothesis, all you really have to do is calculate how often the hypothesis is able to predict the output correctly. If all the predictions are 100% spot-on, then it has a cost of zero. If the predictions are crap, it’ll have a high cost. Bottom line is, <em>we’re trying to optimize for cost – the lower, the better</em>.</p>

<p>Here’s how we can calculate the cost:</p>

<ol>
  <li>For each point in our training dataset, we find the “distance” between the predicted output (i.e. our hypothesis \(h\)) and the actual output (\(y\)).</li>
  <li>We then square this distance, to get rid of weird stuff that happens with negative points (an error is an error, whether the distance is positive or negative).</li>
  <li>Let’s now add all of those squares up.</li>
  <li>Finally take the average of all those figures, so that we can compare errors across different datasets (regardless of the number of data points in any particular set).</li>
  <li>This final step is purely for convenience, and involves multiplying the end result by \(\frac12\) .. to make calculations on the derivative “cleaner” (since \( \frac12 \times 2 = 1 \))</li>
</ol>

<p>Here’s how that looks like mathematically (brace yourselves):</p>

<script type="math/tex; mode=display">J(\theta_0, \theta_1) = \frac{1}{2m} \sum_{i=1}^m \left( h(x^{(i)}) - y^{(i)} \right)^2</script>

<p>I’m not entirely sure why the cost function uses the symbol \(J\) (I would’ve personally used the symbol \(C\), since you know, it’s a Cost function .. but maybe it was already taken or something).</p>

      </div>
    </li>
  
    <li>
      <h2> 
        <a class="post-link" href="/machine-learning/gradient-descent/">Gradient Descent</a>
      </h2>
      <div class="post-content">
        <p>So now we have a hypothesis function and we’ve got a way to measure how accurate it is. All we need now is a way to improve our hypothesis function, eventually finding the best possible \(\theta_0, \theta_1\) values (that minimize our cost).</p>

<p>That’s where <strong>gradient descent</strong> comes in.</p>

<p>Imagine plotting our \(\theta_0, \theta_1\) parameters on the \(x, y\) axes .. and a 3 dimensional \(y\) axis showing the corresponding cost function \(J(\theta_0, \theta_1)\) for those \(\theta_1, \theta_1\) values.</p>

<p>Here’s what that would look like:</p>

<p><img src="/assets/machine-learning/cost-function-vs-thetas.png" alt="Cost function vs thetas" /></p>

<p>What we’re looking for is the point on the graph would the <strong>lowest cost</strong>, which would represent the pit in the center. That’s the sweet spot.. and the values of \(\theta_0\) and \(\theta_1\) at that point are what we are looking for (to optimize our holy hypothesis function \(h\)).</p>

<p>Since plotting these pretty graphs is not always possible (imagine what it would look like if you had just 20 features instead of 1).</p>

<p>Instead then, what we need to do is find a mathematical way to get the answers we need.</p>

<h3 id="the-concept">The Concept</h3>

<p>At the core of the gradient descent technique is a very simple idea. If we can take a starting point - any starting point - and then take a tiny step “downhill” (towards a point with a lower <em>cost</em>), then we’ll eventually get to a pit .. somewhere where we can’t descend any further without going back up. This point is known as the <strong>local minima</strong> and that’s what we’re aiming for.</p>

<p>The only question is: “how do we know which way is downhill?”.</p>

<p>Well, that’s where your old from high school - derivatives - come in. If you remember one thing about derivatives in school, it’s that a derivative is the slope at a given point (if you’re completely lost, check out <a href="https://www.khanacademy.org/math/differential-calculus/taking-derivatives/derivative-intro/v/calculus-derivatives-1">this excellent introduction to derivates</a>).</p>

<p>So all we need to do then is follow the derivative (the slope at a particular point), and it will give us a direction to move towards.</p>

<script type="math/tex; mode=display">\theta_j := \theta_j - \alpha[\text{derivative of J}]</script>

<script type="math/tex; mode=display">\theta_j := \theta_j - \alpha \frac{\partial}{\partial \theta_j} J(\theta_0, \theta_1)</script>

<h3 id="gradient-descent-for-linear-regression">Gradient Descent for Linear Regression</h3>

<p>Assuming we’ve only got one \(x\) and one \(y\) (carrying on the example from the last post), we can start substituting equations in to really drive this point home.</p>

<p>Let’s start by substituting for the value of \(J\) which we derived in <a href="/machine-learning/some-basic-definitions">the previous post</a> as:</p>

<script type="math/tex; mode=display">J(\theta_0, \theta_1) = \frac{1}{2m} \sum_{i=1}^m \left( h(x^{(i)}) - y^{(i)} \right)^2</script>

<p>.. this results in:</p>

<script type="math/tex; mode=display">\theta_j := \theta_j - \alpha \frac{\partial}{\partial \theta_j} \left( \frac{1}{2m} \sum_{i=1}^m \left( h(x^{(i)}) - y^{(i)} \right)^2 \right)</script>

<p>Since we have two variables that we’re trying to optimize (namely \(\theta_0)\) and \(\theta_1\)), we have to use what’s known in the geeky world of mathematics as <em>partial derivatives</em>. While it may sound like I just turned all Math professor on you, it’s actually a simple concept.</p>

<p>It’s like a normal derivative, where you treat everything as a constant except the variable you are deriving by. If that’s not enough by way of introduction, check <a href="http://math.stackexchange.com/questions/70728/partial-derivative-in-gradient-descent-for-two-variables/189792#189792">this great explanation on the Math StackExchange</a> site.</p>

<p>Ok, so here are the final equations we’re looking for (in their simplified form, after rearranging and stuff):</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}

\theta_0 & := \theta_0 - \alpha \frac{1}{m} \sum_{i=1}^m \left(\theta_0 + \theta_{1}x^{(i)} - y^{(i)}\right) \\

\theta_1 & := \theta_1 - \alpha \frac{1}{m} \sum_{i=1}^m \left(\theta_0 +
\theta_{1}x^{(i)} - y^{(i)}\right) x^{(i)}

\end{align} %]]></script>

<p>She’s a real beauty, ain’t she?</p>

<p>And this is just one step. We’ll be running this calculation many, many times .. as we journey down the hill of cost, to the local minima (sometimes thousands of times even).</p>

<h3 id="the-code">The code</h3>

<p>Nothing drives a point home like seeing some code, and I really struggled to get my head around this whole vector business until I actually saw it implemented in traditional arrays.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># y = theta_1 * x + theta_0
# Not actually required in the gradient descent calculation; just used to verify
# the sanity of the results :)
</span><span class="k">def</span> <span class="nf">compute_error_for_line_given_points</span><span class="p">(</span><span class="n">theta_0</span><span class="p">,</span> <span class="n">theta_1</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
  <span class="n">totalError</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
      <span class="n">totalError</span> <span class="o">+=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">theta_1</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">theta_0</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
  <span class="k">return</span> <span class="n">totalError</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">step_gradient</span><span class="p">(</span><span class="n">theta_0_current</span><span class="p">,</span> <span class="n">theta_1_current</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
  <span class="c1"># Gets called for each iteration of 'alpha'
</span>  <span class="n">theta_0_gradient</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">theta_1_gradient</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">m</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">theta_0_gradient</span> <span class="o">+=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="p">((</span><span class="n">theta_1_current</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">theta_0_current</span><span class="p">))</span>
    <span class="n">theta_1_gradient</span> <span class="o">+=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="p">((</span><span class="n">theta_1_current</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">theta_0_current</span><span class="p">))</span>
  <span class="n">new_theta_0</span> <span class="o">=</span> <span class="n">theta_0_current</span> <span class="o">-</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">theta_0_gradient</span><span class="p">)</span>
  <span class="n">new_theta_1</span> <span class="o">=</span> <span class="n">theta_1_current</span> <span class="o">-</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">theta_1_gradient</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">new_theta_0</span><span class="p">,</span> <span class="n">new_theta_1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">gradient_descent_runner</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">starting_theta_0</span><span class="p">,</span> <span class="n">starting_theta_1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">num_iterations</span><span class="p">):</span>
  <span class="c1"># This method simply runs the 'step_gradient' method num_iterations times,
</span>  <span class="c1"># updating the values of theta_0, theta_1 after each iteration.
</span>  <span class="n">theta_0</span> <span class="o">=</span> <span class="n">starting_theta_0</span>
  <span class="n">theta_1</span> <span class="o">=</span> <span class="n">starting_theta_1</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">):</span>
    <span class="n">theta_0</span><span class="p">,</span> <span class="n">theta_1</span> <span class="o">=</span> <span class="n">step_gradient</span><span class="p">(</span><span class="n">theta_0</span><span class="p">,</span> <span class="n">theta_1</span><span class="p">,</span> <span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="n">alpha</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">theta_0</span><span class="p">,</span> <span class="n">theta_1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">run</span><span class="p">():</span>
  <span class="c1"># This method reads all of our data points (x, y)'s and calls the
</span>  <span class="c1"># 'gradient_descent_runner' passing in all of the variables
</span>  <span class="n">points</span> <span class="o">=</span> <span class="n">genfromtxt</span><span class="p">(</span><span class="s">"data.csv"</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">","</span><span class="p">)</span>
  <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.0001</span>
  <span class="n">initial_theta_0</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># initial y-intercept guess
</span>  <span class="n">initial_theta_1</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># initial slope guess
</span>  <span class="n">num_iterations</span> <span class="o">=</span> <span class="mi">1000</span>
  <span class="k">print</span> <span class="s">"Starting gradient descent at theta_0 = {0}, theta_1 = {1}, error = {2}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">initial_theta_0</span><span class="p">,</span> <span class="n">initial_theta_1</span><span class="p">,</span> <span class="n">compute_error_for_line_given_points</span><span class="p">(</span><span class="n">initial_theta_0</span><span class="p">,</span> <span class="n">initial_theta_1</span><span class="p">,</span> <span class="n">points</span><span class="p">))</span>
  <span class="k">print</span> <span class="s">"Running..."</span>
  <span class="p">[</span><span class="n">theta_0</span><span class="p">,</span> <span class="n">theta_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">gradient_descent_runner</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">initial_theta_0</span><span class="p">,</span> <span class="n">initial_theta_1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">num_iterations</span><span class="p">)</span>
  <span class="k">print</span> <span class="s">"After {0} iterations theta_0 = {1}, theta_1 = {2}, error = {3}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">,</span> <span class="n">theta_0</span><span class="p">,</span> <span class="n">theta_1</span><span class="p">,</span> <span class="n">compute_error_for_line_given_points</span><span class="p">(</span><span class="n">theta_0</span><span class="p">,</span> <span class="n">theta_1</span><span class="p">,</span> <span class="n">points</span><span class="p">))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
  <span class="n">run</span><span class="p">()</span></code></pre></figure>

<p>You’ll find the <code class="highlighter-rouge">data.csv</code> file <a href="https://gist.github.com/yazinsai/a962de1d2efcf3aa4986">here</a>.</p>

<p>Here’s what the output looks like:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">&gt;</span> <span class="nv">$python</span> gradient_descent_example.py
Starting gradient descent at theta_0 <span class="o">=</span> 0, theta_1 <span class="o">=</span> 0, error <span class="o">=</span> 2782.55391724
Running...
After 1000 iterations theta_0 <span class="o">=</span> 0.0590585566422, theta_1 <span class="o">=</span> 1.47833132745, error <span class="o">=</span> 56.3163353936</code></pre></figure>

<p>It took me a while to wrap my head around this, and to get the code to a working state. <a href="http://spin.atomicobject.com/2014/06/24/gradient-descent-linear-regression/">Matt Nedrich’s post</a> on the topic was very helpful.</p>

<p><em>Note: I’ve used Python in the example above, but going forward most examples will be written using <a href="http://www.wikiwand.com/en/GNU_Octave">Octave</a>.</em></p>

      </div>
    </li>
  
    <li>
      <h2> 
        <a class="post-link" href="/machine-learning/multivariate-linear-regression/">Multivariate Linear Regression</a>
      </h2>
      <div class="post-content">
        <p>Here’s the deal. So far, we’d only discussed the most basic possible example: a case where you had:</p>

<ul>
  <li>a <strong>single feature</strong> (our \(x\), the area of the house)</li>
  <li>a <strong>single output</strong> (our \(y\), the price of the house)</li>
  <li>and a <strong>linear relationship</strong> between the two</li>
</ul>

<p>Now, we’re about to grow up .. because in the real world, we don’t just have a single feature. We have many .. sometimes even thousands!</p>

<p>Think about it .. it sounds absolutely absurd that you would even think that it’s possible to accurately predict the price of a house based on area alone! So many other things matter, like the number of rooms, the floors, the size of the garden, how old it is and it’s sentimental value to you (actually, scratch that last one).</p>

<p>So that’s what we’ll be covering in this post .. how to consider a more complex prediction example.</p>

<p>Don’t forget our goal .. we’re still trying to come up with a hypothesis function that would allow us to accurately predict the price of the house, based on the inputs we’re given.</p>

<p>Let’s do this.</p>

<h3 id="revisiting-our-now-broken-equations">Revisiting our (now broken) equations</h3>

<p>We’re going to have to go back and fix the equations we discussed earlier. The definitions (or rather, the meaning) of the equations won’t change .. but we no longer have just one \(x\) to deal with.</p>

<p>First, <strong>a few new definitions.</strong></p>

<p>Since we have many \(x\)’s now, let’s give them subscripts (e.g. \(x_1, x_2, x_3\)) to refer to our different features.</p>

<p>Note that we already said that the bracketed-superscripts for \(x\) (like \(x^{(1)}, x^{(2)}\), etc.) represent samples in the training set. This still holds true. We just have to get used to seeing things like \(x_1^{(2)}\), which is the second row (or data point in our training data) of the first feature.</p>

<p>We also need a way to refer to the total number of features we’ve got .. let’s go ahead and call that \(n\).</p>

<p>Now that we have that out of the way, let’s take a look at those equations .. starting with our hypothesis \(h_0(x)\).</p>

<h4 id="hypothesis-function-h_thetax">Hypothesis function \(h_\theta(x)\)</h4>

<p><strong>Before</strong> (we had only one \(x\)):
<script type="math/tex">h_\theta(x) = \theta_0 + \theta_1 x</script></p>

<p><strong>After</strong> (we have many \(x\)’s):
<script type="math/tex">h_\theta(x) = \theta_0 + \theta_1 x_1 + \theta_2 x_2 + \text{...}</script></p>

<p>You’ll notice something going on here .. all the terms have both \(\theta\)’s and \(x\)’s .. except for that first one, the lonely looking \(\theta_0\). To simplify things, let’s go ahead and give it an \(x_0\) that has a value of 1 (so that it doesn’t change the equation in any way).</p>

<p>Now, it looks like:</p>

<p><script type="math/tex">h_\theta(x) = \theta_0 x_0 + \theta_1 x_1 + \theta_2 x_2 + \text{...}</script>
<em>(where \(x_0=1\))</em></p>

<p>Let’s take the next jump .. let’s lump up all of those \(\theta_0, \theta_1, \theta_2\), … parameters into a single vector like so:</p>

<script type="math/tex; mode=display">\theta =
\begin{bmatrix}
\theta_0 \\
\theta_1 \\
\theta_2 \\
\vdots \\
\theta_n
\end{bmatrix}</script>

<p>.. and similarly ..</p>

<script type="math/tex; mode=display">x =
\begin{bmatrix}
x_0 \\
x_1 \\
x_2 \\
\vdots \\
x_n
\end{bmatrix}</script>

<p>Those weird looking towers are known in the mathematics parlance as <em>matrices</em>. If you have no idea what those are, you can think of them as layers of numbers, not very different from your good ole’ Big Mac. If you want to learn more, just check out this <a href="https://www.khanacademy.org/math/algebra2/alg-2-old-content/basic-matrix-operations-alg2/v/introduction-to-the-matrix">video here</a>. You may or may not remember that a matrix with just one column is known as a <em>vector</em>.</p>

<p>So here, we’re treating our \(\theta\) and our \(x\) as a single vector, as opposed to many tiny numbers with little subscripts.</p>

<p>So now, <strong>our new hypothesis equation</strong> will simply be:</p>

<script type="math/tex; mode=display">h_\theta(x) = \theta^T x</script>

<p>That weird looking T on top of the \(\theta\) is known as the <em>transpose</em> of \(\theta\), or \(\theta\) flipped on it’s side like so:</p>

<script type="math/tex; mode=display">% <![CDATA[
\theta^T =
\begin{bmatrix}
\theta_0 & \theta_1 & \theta_2 & \cdots & \theta_n
\end{bmatrix} %]]></script>

<p>The reason we use \(\theta^T\) and not \(\theta\) is so that the multiplication will work (if you don’t know how to multiply matrices, check out <a href="https://www.khanacademy.org/math/algebra2/alg-2-old-content/matrix-multiplication-alg2/v/matrix-multiplication-intro">this short video</a> for a primer).</p>

<p>We now have a new equation for our hypothesis function! (keeping in mind that \(x_0=1\) or this whole business just won’t work).</p>

<h4 id="cost-function-jtheta">Cost function \(J(\theta)\)</h4>

<p>Our new and improved cost function now looks like this:</p>

<script type="math/tex; mode=display">J(\theta) = \frac{1}{2m} \sum_{i=1}^m \left(\ h_\theta(x^{(i)}) - y^{(i)} \right)^2</script>

<p>Next, let’s take a look at our gradient descent equation.</p>

<h4 id="gradient-descent">Gradient descent</h4>

<p>If you’ll recall, the gradient descent equation in the case of a single feature looked like this:</p>

<script type="math/tex; mode=display">\theta_j := \theta_j - \alpha \frac{\partial}{\partial \theta_j} J(\theta)</script>

<p>Substituting for \(J(\theta)\), that becomes:</p>

<script type="math/tex; mode=display">\theta_j := \theta_j - \alpha \frac{\partial}{\partial \theta_j} \left( \frac{1}{2m} \sum_{i=1}^m \left( h(x^{(i)}) - y^{(i)} \right)^2 \right)</script>

<p>We then computed the partial derivative for each of our \(\theta_0, \theta_1\) individually, resulting in:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}

\theta_0 & := \theta_0 - \alpha \frac{1}{m} \sum_{i=1}^m \left(h(x^{(i)}) - y^{(i)}\right) \\

\theta_1 & := \theta_1 - \alpha \frac{1}{m} \sum_{i=1}^m \left(h(x^{(i)}) - y^{(i)}\right) x^{(i)}

\end{align} %]]></script>

<p>When replacing this with multiple features, my expectation was that things would get ickier .. much ickier. In fact, I was pleasantly surprised to realize that it wasn’t the case at all.</p>

<p>A fundamental property of partial derivatives is that you only calculate the derivative with reference to the variable you’re deriving with (which are our \(\theta_0, \theta_1\), etc. variables).</p>

<p>Since we’re only going to be computing the derivative with respect to <em>one</em> of these variables at a time, the resulting derivative looks just like the \(\theta_1\) term above.</p>

<p>Namely, it’ll be:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}

\theta_0 & := \theta_0 - \alpha \frac{1}{m} \sum_{i=1}^m \left(h(x^{(i)}) - y^{(i)}\right) \\

\theta_1 & := \theta_1 - \alpha \frac{1}{m} \sum_{i=1}^m \left(h(x^{(i)}) - y^{(i)}\right) x_1^{(i)} \\

\theta_2 & := \theta_2 - \alpha \frac{1}{m} \sum_{i=1}^m \left(h(x^{(i)}) - y^{(i)}\right) x_2^{(i)}

\end{align} %]]></script>

<p>Not too bad, huh?</p>

<p>All the equations look similar except for the first one. Wait .. remember that lonely \(x_0=1\) we were talking about earlier? Well, turns out it’s their in that first equation .. but we just didn’t see it (since it’s equal to 1):</p>

<script type="math/tex; mode=display">\theta_0 := \theta_0 - \alpha \frac{1}{m} \sum_{i=1}^m \left(h(x^{(i)}) - y^{(i)}\right) x_0^{(i)}</script>

<p>Now let’s write it in the general form:</p>

<script type="math/tex; mode=display">\theta_j := \theta_j - \alpha \frac{1}{m} \sum_{i=1}^m \left(h(x^{(i)}) - y^{(i)}\right) x_j^{(i)}</script>

<p>Kill the feature subset (represented by the subscript \(j\), since \(\theta\) is a vector anyway) and we’re left with:</p>

<script type="math/tex; mode=display">\theta := \theta - \alpha \frac{1}{m} \sum_{i=1}^m \left(h(x^{(i)}) - y^{(i)}\right) x^{(i)}</script>

<p>I don’t know about you but I’m feeling like I’ve had my fair share of math for now .. let’s jump into some good ole’ fashioned code.</p>

<h2 id="implementing-things-in-code">Implementing things in code</h2>

<p>Alright, enough of this math business .. let’s take a look at some code. I’ll be using <strong>Octave</strong> in this example, since that’s what the Machine Learning course uses (and it makes dealing with matrices, as well as all the rest of the Machine Learning stuff pretty easy).</p>

<p>So yeah, Octave. The syntax is pretty self-explanatory, though writing it will take a bit of getting used to (at least for me anyway).</p>

      </div>
    </li>
  
    <li>
      <h2> 
        <a class="post-link" href="/machine-learning/tricks-to-converge-faster/">Tricks to make Gradient Descent converge faster</a>
      </h2>
      <div class="post-content">
        <h3 id="trick-1-normalize-your-data">Trick #1: Normalize your data</h3>

<p>You know how you were always trying to fit in as a kid? Well, it turns out that’s good advice for our features to heed.</p>

<p>It can be proved that if your features have greatly varying ranges, then it would almost certainly take longer for gradient descent to find the local minima.</p>

<p>For example, let’s take the features below:</p>

<p>\(x_1\) = Size of the bedroom (0 - 2000 ft\(^2\))</p>

<p>\(x_2\) = Number of bedrooms (1 - 5 rooms)</p>

<p>The ideal feature would fit within the range \(-1 \le x \le +1\)</p>

<p>Just keep in mind that this is an approximate range ( \(-2 \le x \le 3 \) is fine too .. but \(-1,000 \le x \le 250\) is <strong>not</strong>)</p>

<p>Knowing what we know now, we can easily normalize \(x_1, x_2\) to fit within that range by doing:</p>

<script type="math/tex; mode=display">x_1 = \frac{\text{Size of bedroom}}{2000}</script>

<script type="math/tex; mode=display">x_2 = \frac{\text{Number of bedrooms}}{5}</script>

<p>Voila, we’re all done.</p>

<p><strong>Note:</strong> There’s another form of normalization called “Mean normalization” where you try to center the averages. Frankly, I’m feeling way too lazy to be writing about that right now .. so we’re skipping it. Read about it <a href="http://www.d.umn.edu/~deoka001/Normalization.html">here</a> if you dig that sort of thing.</p>

<h3 id="trick-2-picking-a-learning-rate-alpha">Trick #2: Picking a learning rate, \(\alpha\)</h3>

<p>We’ve discussed \(\alpha\) before, but we haven’t really talked much about how we initially decide on what value to choose.</p>

<p>Turns out, you just gotta try a bunch of values and see what works best. Rather than brute forcing every number in existence though, you can take a more visual approach.</p>

<p>Try to plot <code class="highlighter-rouge">number of iterations</code> vs. \(J(\theta)\):</p>

<p><img src="/assets/machine-learning/tricks-plot-cost-vs-iterations.png" alt="Number of iterations vs. Cost" /></p>

<p>If your \(J(\theta)\) isn’t decreasing after <em>every</em> iteration, then something isn’t right.</p>

<p>You can try the following values for \(\alpha\), starting with the smallest and moving up (until you see the values diverge):</p>

<p><code class="highlighter-rouge">0.001</code>, <code class="highlighter-rouge">0.003</code>, <code class="highlighter-rouge">0.01</code>, <code class="highlighter-rouge">0.03</code>, <code class="highlighter-rouge">0.1</code>, <code class="highlighter-rouge">0.3</code>, <code class="highlighter-rouge">1</code>
(so basically just start at <code class="highlighter-rouge">0.001</code> and keep multiplying by approx. 3)</p>

<h3 id="interesting-note">Interesting Note</h3>

<p>An interesting aside is that you can make all sorts of crazy changes to your initial data and magically conjure new features that way.</p>

<p>The action starts with a plot of the feature itself vs. the output you’re measuring:</p>

<p><img src="/assets/machine-learning/tricks-fitting.png" alt="Fitting a curve" /></p>

<p>Looking at this curve, you might think .. you know what? There kinda looks like there might be some square-root relationship going on between the \(x\) and the \(y\) .. so why don’t I just use \(\sqrt(x)\) as a feature instead of plain old \(x\) (or even in addition to the \(x\)).</p>

<p>That’s <em>totally cool</em>. Now, you’re hypothesis would look like:</p>

<script type="math/tex; mode=display">h(\theta) = \theta_0 + \theta_1 x + \theta_2 \sqrt{x}</script>

      </div>
    </li>
  
</ul>

<p class="rss-subscribe">subscribe <a href="/feed.xml">via RSS</a></p>





<footer> 
</footer>

<!-- Google Analytics Tracking code -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-89256258-1', 'auto');
  ga('send', 'pageview');

</script>



</body>
</html>
